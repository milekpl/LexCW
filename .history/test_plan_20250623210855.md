# Comprehensive Unit Testing Plan

This document outlines a detailed unit testing plan for the Dictionary Writing System, covering all key components and features to ensure robustness, correctness, and maintainability.

## 1. Testing Frameworks and Tools

### 1.1 Core Testing Technologies

- **PyTest**: Primary framework for Python unit and integration tests
- **Coverage.py**: For measuring test coverage metrics
- **Hypothesis**: For property-based testing of complex data structures
- **pytest-mock**: For mocking dependencies in unit tests
- **pytest-httpx**: For mocking HTTP requests
- **pytest-asyncio**: For testing asynchronous code

### 1.2 Database Testing

- **BaseX Test Suite**: For XML database testing
- **pytest-mongodb**: For testing MongoDB interactions (if used for caching)
- **pytest-sqlite**: For testing SQLite export functionality

### 1.3 CI/CD Integration

- **GitHub Actions**: For automated test execution
- **SonarQube**: For code quality analysis
- **Pre-commit hooks**: For running tests before commits

## 2. Directory Structure

```plaintext
flask-app/
├── tests/
│   ├── unit/
│   │   ├── models/
│   │   ├── parsers/
│   │   ├── services/
│   │   ├── api/
│   │   └── utils/
│   ├── integration/
│   │   ├── database/
│   │   ├── api/
│   │   └── services/
│   ├── fixtures/
│   │   ├── lift_files/
│   │   ├── writing_systems/
│   │   └── export_templates/
│   └── conftest.py
```

## 3. Core Components Testing

### 3.1 LIFT Parser and Generator

#### 3.1.1 Parser Tests

- **Basic Parsing**: Test parsing of simple valid LIFT files
- **Complex Parsing**: Test parsing of LIFT files with nested structures
- **Error Handling**: Test parsing of malformed XML and recovery
- **Performance**: Test parsing performance with large LIFT files
- **Memory Usage**: Test memory consumption during parsing

#### 3.1.2 Sample Test Cases for Parser

```python
def test_parse_basic_entry():
    """Test parsing a basic entry with minimal attributes."""
    parser = LIFTParser()
    xml_content = """
    <lift version="0.13">
      <entry id="test_entry">
        <lexical-unit>
          <form lang="en"><text>test</text></form>
        </lexical-unit>
      </entry>
    </lift>
    """
    entries = parser.parse_string(xml_content)
    assert len(entries) == 1
    assert entries[0].id == "test_entry"
    assert entries[0].lexical_unit["en"] == "test"

def test_parse_entry_with_multiple_senses():
    """Test parsing an entry with multiple senses."""
    parser = LIFTParser()
    xml_content = """
    <lift version="0.13">
      <entry id="test_entry">
        <lexical-unit>
          <form lang="en"><text>test</text></form>
        </lexical-unit>
        <sense id="sense1">
          <definition>
            <form lang="pl"><text>próba</text></form>
          </definition>
        </sense>
        <sense id="sense2">
          <definition>
            <form lang="pl"><text>testować</text></form>
          </definition>
        </sense>
      </entry>
    </lift>
    """
    entries = parser.parse_string(xml_content)
    assert len(entries) == 1
    assert len(entries[0].senses) == 2
    assert entries[0].senses[0].id == "sense1"
    assert entries[0].senses[0].definitions["pl"] == "próba"
    assert entries[0].senses[1].id == "sense2"
    assert entries[0].senses[1].definitions["pl"] == "testować"

def test_parse_entry_with_examples():
    """Test parsing an entry with examples."""
    parser = LIFTParser()
    xml_content = """
    <lift version="0.13">
      <entry id="test_entry">
        <lexical-unit>
          <form lang="en"><text>test</text></form>
        </lexical-unit>
        <sense id="sense1">
          <example>
            <form lang="en"><text>This is a test.</text></form>
            <translation>
              <form lang="pl"><text>To jest próba.</text></form>
            </translation>
          </example>
        </sense>
      </entry>
    </lift>
    """
    entries = parser.parse_string(xml_content)
    assert len(entries) == 1
    assert len(entries[0].senses[0].examples) == 1
    assert entries[0].senses[0].examples[0].form["en"] == "This is a test."
    assert entries[0].senses[0].examples[0].translations["pl"] == "To jest próba."

def test_parse_entry_with_pronunciations():
    """Test parsing an entry with pronunciations."""
    parser = LIFTParser()
    xml_content = """
    <lift version="0.13">
      <entry id="test_entry">
        <lexical-unit>
          <form lang="en"><text>test</text></form>
        </lexical-unit>
        <pronunciation>
          <form lang="seh-fonipa"><text>test</text></form>
        </pronunciation>
      </entry>
    </lift>
    """
    entries = parser.parse_string(xml_content)
    assert len(entries) == 1
    assert entries[0].pronunciations["seh-fonipa"] == "test"

def test_handle_malformed_xml():
    """Test handling of malformed XML."""
    parser = LIFTParser()
    xml_content = """
    <lift version="0.13">
      <entry id="test_entry">
        <lexical-unit>
          <form lang="en"><text>test</text></form>
        </lexical-unit>
      <entry>  <!-- Missing closing tag -->
    </lift>
    """
    with pytest.raises(Exception) as excinfo:
        parser.parse_string(xml_content)
    assert "XML" in str(excinfo.value)
```

#### 3.1.3 Generator Tests

- **Basic Generation**: Test generating simple LIFT files
- **Complex Generation**: Test generating LIFT files with nested structures
- **Round-trip Testing**: Test parsing → modifying → generating → parsing again
- **Validation**: Test validation of generated LIFT against schema

#### 3.1.4 Sample Test Cases for Generator

```python
def test_generate_basic_entry():
    """Test generating a basic entry."""
    generator = LIFTGenerator()
    entry = Entry(id="test_entry")
    entry.lexical_unit = {"en": "test"}
    
    xml_content = generator.generate_entry(entry)
    
    # Parse the generated XML to verify its structure
    parser = LIFTParser()
    entries = parser.parse_string(f"<lift version='0.13'>{xml_content}</lift>")
    
    assert len(entries) == 1
    assert entries[0].id == "test_entry"
    assert entries[0].lexical_unit["en"] == "test"

def test_round_trip_conversion():
    """Test round-trip conversion of a complex entry."""
    # Start with a complex XML
    original_xml = """
    <lift version="0.13">
      <entry id="test_entry">
        <lexical-unit>
          <form lang="en"><text>test</text></form>
        </lexical-unit>
        <pronunciation>
          <form lang="seh-fonipa"><text>test</text></form>
        </pronunciation>
        <sense id="sense1">
          <grammatical-info value="Noun"/>
          <definition>
            <form lang="pl"><text>próba</text></form>
          </definition>
          <example>
            <form lang="en"><text>This is a test.</text></form>
            <translation>
              <form lang="pl"><text>To jest próba.</text></form>
            </translation>
          </example>
        </sense>
      </entry>
    </lift>
    """
    
    # Parse it
    parser = LIFTParser()
    entries = parser.parse_string(original_xml)
    
    # Generate XML from the parsed entries
    generator = LIFTGenerator()
    xml_content = generator.generate_entries(entries)
    
    # Parse the generated XML
    regenerated_entries = parser.parse_string(f"<lift version='0.13'>{xml_content}</lift>")
    
    # Verify the structures match
    assert len(entries) == len(regenerated_entries)
    assert entries[0].id == regenerated_entries[0].id
    assert entries[0].lexical_unit == regenerated_entries[0].lexical_unit
    assert entries[0].pronunciations == regenerated_entries[0].pronunciations
    assert entries[0].senses[0].id == regenerated_entries[0].senses[0].id
    assert entries[0].senses[0].grammatical_info == regenerated_entries[0].senses[0].grammatical_info
    assert entries[0].senses[0].definitions == regenerated_entries[0].senses[0].definitions
```

### 3.2 BaseX Database Connector

#### 3.2.1 Connection Tests

- **Connection Establishment**: Test connecting to BaseX
- **Authentication**: Test authentication mechanisms
- **Connection Pooling**: Test connection pooling for performance
- **Error Handling**: Test handling of connection errors
- **Reconnection**: Test automatic reconnection after failures

#### 3.2.2 Sample Test Cases for Connection

```python
def test_connection_establishment(mock_basex_server):
    """Test establishing a connection to BaseX."""
    connector = BaseXConnector(
        host="localhost",
        port=1984,
        username="admin",
        password="admin"
    )
    assert connector.connect() is True
    assert connector.is_connected() is True
    connector.disconnect()
    assert connector.is_connected() is False

def test_authentication_failure(mock_basex_server):
    """Test handling of authentication failures."""
    connector = BaseXConnector(
        host="localhost",
        port=1984,
        username="admin",
        password="wrong_password"
    )
    with pytest.raises(AuthenticationError):
        connector.connect()
    assert connector.is_connected() is False

def test_connection_timeout(mock_basex_server_delayed):
    """Test handling of connection timeouts."""
    connector = BaseXConnector(
        host="localhost",
        port=1984,
        username="admin",
        password="admin",
        timeout=1  # 1 second timeout
    )
    with pytest.raises(ConnectionTimeoutError):
        connector.connect()
    assert connector.is_connected() is False
```

#### 3.2.3 Query Tests

- **Basic Queries**: Test executing simple XQuery statements
- **Complex Queries**: Test executing complex XQuery statements
- **Performance**: Test query performance with large databases
- **Error Handling**: Test handling of query errors
- **Result Processing**: Test processing of query results

#### 3.2.4 Sample Test Cases for Queries

```python
def test_basic_query(basex_connector):
    """Test executing a basic XQuery."""
    result = basex_connector.execute_query("count(//entry)")
    assert result.is_numeric()
    assert result.get_int() >= 0

def test_entry_retrieval_by_id(basex_connector):
    """Test retrieving an entry by ID."""
    entry_id = "test_entry"
    result = basex_connector.execute_query(f"""
        for $entry in //entry[@id="{entry_id}"]
        return $entry
    """)
    assert result.is_xml()
    xml_content = result.get_xml()
    assert f'id="{entry_id}"' in xml_content

def test_update_entry(basex_connector):
    """Test updating an entry."""
    entry_id = "test_entry"
    new_form = "updated_test"
    
    # Update the entry
    result = basex_connector.execute_update(f"""
        for $entry in //entry[@id="{entry_id}"]
        return replace value of node $entry/lexical-unit/form/text with "{new_form}"
    """)
    assert result.is_success()
    
    # Verify the update
    result = basex_connector.execute_query(f"""
        for $entry in //entry[@id="{entry_id}"]
        return $entry/lexical-unit/form/text/string()
    """)
    assert result.get_string() == new_form
```

#### 3.2.5 Transaction Tests

- **Basic Transactions**: Test beginning, committing, and rolling back transactions
- **Nested Transactions**: Test handling of nested transactions
- **Concurrency**: Test concurrent transactions
- **Error Handling**: Test transaction error handling and recovery
- **Isolation Levels**: Test different transaction isolation levels

#### 3.2.6 Sample Test Cases for Transactions

```python
def test_basic_transaction(basex_connector):
    """Test basic transaction operations."""
    # Begin transaction
    basex_connector.begin_transaction()
    
    # Make changes
    entry_id = "test_entry"
    new_form = "transaction_test"
    basex_connector.execute_update(f"""
        for $entry in //entry[@id="{entry_id}"]
        return replace value of node $entry/lexical-unit/form/text with "{new_form}"
    """)
    
    # Commit transaction
    basex_connector.commit_transaction()
    
    # Verify changes persisted
    result = basex_connector.execute_query(f"""
        for $entry in //entry[@id="{entry_id}"]
        return $entry/lexical-unit/form/text/string()
    """)
    assert result.get_string() == new_form

def test_transaction_rollback(basex_connector):
    """Test transaction rollback."""
    # Get original value
    entry_id = "test_entry"
    result = basex_connector.execute_query(f"""
        for $entry in //entry[@id="{entry_id}"]
        return $entry/lexical-unit/form/text/string()
    """)
    original_form = result.get_string()
    
    # Begin transaction
    basex_connector.begin_transaction()
    
    # Make changes
    new_form = "rollback_test"
    basex_connector.execute_update(f"""
        for $entry in //entry[@id="{entry_id}"]
        return replace value of node $entry/lexical-unit/form/text with "{new_form}"
    """)
    
    # Verify changes in transaction
    result = basex_connector.execute_query(f"""
        for $entry in //entry[@id="{entry_id}"]
        return $entry/lexical-unit/form/text/string()
    """)
    assert result.get_string() == new_form
    
    # Rollback transaction
    basex_connector.rollback_transaction()
    
    # Verify changes were rolled back
    result = basex_connector.execute_query(f"""
        for $entry in //entry[@id="{entry_id}"]
        return $entry/lexical-unit/form/text/string()
    """)
    assert result.get_string() == original_form
```

### 3.3 Model Tests

#### 3.3.1 Entry Model Tests

- **Basic Properties**: Test basic properties and validation
- **Relationships**: Test relationship management
- **Validation**: Test validation rules
- **Serialization**: Test serialization to/from different formats
- **Memory Usage**: Test memory consumption with large entries

#### 3.3.2 Sample Test Cases for Entry Model

```python
def test_entry_creation():
    """Test creating an entry with basic properties."""
    entry = Entry(id="test_entry")
    entry.lexical_unit = {"en": "test"}
    
    assert entry.id == "test_entry"
    assert entry.lexical_unit["en"] == "test"
    assert len(entry.senses) == 0

def test_entry_validation():
    """Test entry validation rules."""
    # Missing required ID
    with pytest.raises(ValidationError):
        entry = Entry()
        entry.validate()
    
    # Valid entry
    entry = Entry(id="test_entry")
    entry.lexical_unit = {"en": "test"}
    assert entry.validate() is True

def test_entry_with_senses():
    """Test entry with senses."""
    entry = Entry(id="test_entry")
    entry.lexical_unit = {"en": "test"}
    
    sense1 = Sense(id="sense1")
    sense1.definitions = {"pl": "próba"}
    
    sense2 = Sense(id="sense2")
    sense2.definitions = {"pl": "testować"}
    
    entry.add_sense(sense1)
    entry.add_sense(sense2)
    
    assert len(entry.senses) == 2
    assert entry.senses[0].id == "sense1"
    assert entry.senses[1].id == "sense2"

def test_entry_serialization():
    """Test entry serialization to/from dict."""
    entry = Entry(id="test_entry")
    entry.lexical_unit = {"en": "test"}
    entry.pronunciations = {"seh-fonipa": "test"}
    
    sense = Sense(id="sense1")
    sense.definitions = {"pl": "próba"}
    sense.grammatical_info = "Noun"
    
    example = Example()
    example.form = {"en": "This is a test."}
    example.translations = {"pl": "To jest próba."}
    
    sense.add_example(example)
    entry.add_sense(sense)
    
    # Serialize to dict
    data = entry.to_dict()
    
    # Create new entry from dict
    new_entry = Entry.from_dict(data)
    
    # Verify
    assert new_entry.id == entry.id
    assert new_entry.lexical_unit == entry.lexical_unit
    assert new_entry.pronunciations == entry.pronunciations
    assert len(new_entry.senses) == len(entry.senses)
    assert new_entry.senses[0].id == entry.senses[0].id
    assert new_entry.senses[0].definitions == entry.senses[0].definitions
    assert new_entry.senses[0].grammatical_info == entry.senses[0].grammatical_info
    assert len(new_entry.senses[0].examples) == len(entry.senses[0].examples)
```

#### 3.3.3 Sense Model Tests

- **Basic Properties**: Test basic properties and validation
- **Examples**: Test example management
- **Semantic Relations**: Test semantic relation management
- **Validation**: Test validation rules
- **Serialization**: Test serialization to/from different formats

#### 3.3.4 Sample Test Cases for Sense Model

```python
def test_sense_creation():
    """Test creating a sense with basic properties."""
    sense = Sense(id="sense1")
    sense.definitions = {"pl": "próba"}
    sense.grammatical_info = "Noun"
    
    assert sense.id == "sense1"
    assert sense.definitions["pl"] == "próba"
    assert sense.grammatical_info == "Noun"
    assert len(sense.examples) == 0

def test_sense_with_examples():
    """Test sense with examples."""
    sense = Sense(id="sense1")
    
    example1 = Example()
    example1.form = {"en": "This is a test."}
    example1.translations = {"pl": "To jest próba."}
    
    example2 = Example()
    example2.form = {"en": "Another test."}
    example2.translations = {"pl": "Kolejna próba."}
    
    sense.add_example(example1)
    sense.add_example(example2)
    
    assert len(sense.examples) == 2
    assert sense.examples[0].form["en"] == "This is a test."
    assert sense.examples[1].form["en"] == "Another test."

def test_sense_validation():
    """Test sense validation rules."""
    # Missing required ID
    with pytest.raises(ValidationError):
        sense = Sense()
        sense.validate()
    
    # Valid sense
    sense = Sense(id="sense1")
    assert sense.validate() is True
```

### 3.4 Service Tests

#### 3.4.1 Dictionary Service Tests

- **Entry Management**: Test entry creation, retrieval, update, and deletion
- **Batch Operations**: Test batch operations on entries
- **Search**: Test search functionality
- **Export**: Test export functionality
- **Import**: Test import functionality
- **Validation**: Test validation functionality
- **Performance**: Test performance with large dictionaries

#### 3.4.2 Sample Test Cases for Dictionary Service

```python
def test_entry_retrieval(dictionary_service):
    """Test retrieving an entry by ID."""
    entry = dictionary_service.get_entry("test_entry")
    assert entry is not None
    assert entry.id == "test_entry"

def test_entry_creation(dictionary_service):
    """Test creating a new entry."""
    entry = Entry(id="new_entry")
    entry.lexical_unit = {"en": "new test"}
    
    result = dictionary_service.create_entry(entry)
    assert result is True
    
    # Verify entry was created
    entry = dictionary_service.get_entry("new_entry")
    assert entry is not None
    assert entry.id == "new_entry"
    assert entry.lexical_unit["en"] == "new test"

def test_entry_update(dictionary_service):
    """Test updating an existing entry."""
    entry = dictionary_service.get_entry("test_entry")
    entry.lexical_unit = {"en": "updated test"}
    
    result = dictionary_service.update_entry(entry)
    assert result is True
    
    # Verify entry was updated
    entry = dictionary_service.get_entry("test_entry")
    assert entry is not None
    assert entry.lexical_unit["en"] == "updated test"

def test_entry_deletion(dictionary_service):
    """Test deleting an entry."""
    result = dictionary_service.delete_entry("test_entry")
    assert result is True
    
    # Verify entry was deleted
    entry = dictionary_service.get_entry("test_entry")
    assert entry is None

def test_basic_search(dictionary_service):
    """Test basic search functionality."""
    results = dictionary_service.search("test")
    assert len(results) > 0
    assert any(entry.lexical_unit.get("en") == "test" for entry in results)

def test_advanced_search(dictionary_service):
    """Test advanced search with multiple criteria."""
    criteria = {
        "lexical_unit": "test",
        "grammatical_info": "Noun",
        "language": "en"
    }
    results = dictionary_service.advanced_search(criteria)
    assert len(results) > 0
    assert all(entry.lexical_unit.get("en", "").lower().find("test") >= 0 for entry in results)
    assert all(any(sense.grammatical_info == "Noun" for sense in entry.senses) for entry in results)
```

#### 3.4.3 Pronunciation Service Tests

- **IPA Validation**: Test IPA validation rules
- **TTS Integration**: Test Text-to-Speech integration
- **Audio Storage**: Test audio storage and retrieval
- **Batch Processing**: Test batch processing of pronunciations
- **Error Handling**: Test error handling for invalid pronunciations

#### 3.4.4 Sample Test Cases for Pronunciation Service

```python
def test_ipa_validation(pronunciation_service):
    """Test IPA validation rules."""
    # Valid IPA
    assert pronunciation_service.validate_ipa("ˈtest") is True
    
    # Invalid IPA (contains invalid character)
    assert pronunciation_service.validate_ipa("test123") is False
    
    # Invalid IPA (invalid sequence)
    assert pronunciation_service.validate_ipa("ˈˈtest") is False

def test_tts_generation(pronunciation_service, mock_google_tts):
    """Test TTS audio generation."""
    audio_data = pronunciation_service.generate_audio("test", "en-US")
    assert audio_data is not None
    assert len(audio_data) > 0

def test_audio_storage(pronunciation_service, mock_google_tts):
    """Test audio storage and retrieval."""
    # Generate and store audio
    entry_id = "test_entry"
    pronunciation_service.generate_and_store_audio(entry_id, "test", "en-US")
    
    # Retrieve audio
    audio_data = pronunciation_service.get_audio(entry_id)
    assert audio_data is not None
    assert len(audio_data) > 0

def test_batch_processing(pronunciation_service, mock_google_tts):
    """Test batch processing of pronunciations."""
    entries = [
        {"id": "entry1", "text": "test1"},
        {"id": "entry2", "text": "test2"},
        {"id": "entry3", "text": "test3"}
    ]
    
    results = pronunciation_service.batch_process(entries, "en-US")
    assert len(results) == 3
    assert all(result["success"] for result in results)
    assert all("audio_path" in result for result in results)
```

### 3.5 API Tests

#### 3.5.1 Entry API Tests

- **CRUD Operations**: Test create, read, update, and delete operations
- **Validation**: Test input validation
- **Authentication**: Test authentication and authorization
- **Error Handling**: Test error handling
- **Performance**: Test API performance

#### 3.5.2 Sample Test Cases for Entry API

```python
def test_get_entry(client, auth_token):
    """Test GET /api/entries/{entry_id}."""
    response = client.get(
        "/api/entries/test_entry",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert data["id"] == "test_entry"
    assert "lexical_unit" in data

def test_create_entry(client, auth_token):
    """Test POST /api/entries."""
    entry_data = {
        "id": "new_api_entry",
        "lexical_unit": {"en": "new api test"}
    }
    
    response = client.post(
        "/api/entries",
        json=entry_data,
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 201
    data = response.json()
    assert data["id"] == "new_api_entry"
    
    # Verify entry was created
    response = client.get(
        "/api/entries/new_api_entry",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200

def test_update_entry(client, auth_token):
    """Test PUT /api/entries/{entry_id}."""
    entry_data = {
        "id": "test_entry",
        "lexical_unit": {"en": "updated api test"}
    }
    
    response = client.put(
        "/api/entries/test_entry",
        json=entry_data,
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200
    
    # Verify entry was updated
    response = client.get(
        "/api/entries/test_entry",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert data["lexical_unit"]["en"] == "updated api test"

def test_delete_entry(client, auth_token):
    """Test DELETE /api/entries/{entry_id}."""
    response = client.delete(
        "/api/entries/test_entry",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 204
    
    # Verify entry was deleted
    response = client.get(
        "/api/entries/test_entry",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 404
```

#### 3.5.3 Search API Tests

- **Basic Search**: Test basic search API
- **Advanced Search**: Test advanced search API
- **Pagination**: Test result pagination
- **Sorting**: Test result sorting
- **Filtering**: Test result filtering

#### 3.5.4 Sample Test Cases for Search API

```python
def test_basic_search(client, auth_token):
    """Test GET /api/search?q={query}."""
    response = client.get(
        "/api/search?q=test",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "results" in data
    assert len(data["results"]) > 0
    assert "total" in data
    assert data["total"] > 0

def test_advanced_search(client, auth_token):
    """Test POST /api/search/advanced."""
    search_criteria = {
        "lexical_unit": "test",
        "grammatical_info": "Noun",
        "language": "en"
    }
    
    response = client.post(
        "/api/search/advanced",
        json=search_criteria,
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "results" in data
    assert len(data["results"]) > 0
    assert "total" in data
    assert data["total"] > 0

def test_search_pagination(client, auth_token):
    """Test search pagination."""
    response = client.get(
        "/api/search?q=test&page=1&per_page=5",
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "results" in data
    assert len(data["results"]) <= 5
    assert "total" in data
    assert "page" in data
    assert data["page"] == 1
    assert "per_page" in data
    assert data["per_page"] == 5
    assert "pages" in data
```

### 3.6 Export Tests

#### 3.6.1 Kindle Export Tests

- **Basic Export**: Test basic Kindle export
- **Large Dictionary**: Test export of large dictionaries
- **Custom Templates**: Test custom export templates
- **Validation**: Test validation of exported files
- **Performance**: Test export performance

#### 3.6.2 Sample Test Cases for Kindle Export

```python
def test_basic_kindle_export(kindle_exporter, sample_entries):
    """Test basic Kindle export functionality."""
    output_path = "tests/fixtures/output/kindle_export_test.opf"
    result = kindle_exporter.export(sample_entries, output_path)
    
    assert result is True
    assert os.path.exists(output_path)
    
    # Validate OPF file structure
    with open(output_path, "r", encoding="utf-8") as f:
        content = f.read()
        assert "<?xml" in content
        assert "<package" in content
        assert "<dc:title" in content
        assert "<dc:language" in content
        assert "<reference type=\"text\"" in content

def test_kindle_export_with_template(kindle_exporter, sample_entries):
    """Test Kindle export with custom template."""
    template_path = "tests/fixtures/templates/custom_kindle_template.opf"
    output_path = "tests/fixtures/output/kindle_custom_export_test.opf"
    
    result = kindle_exporter.export_with_template(sample_entries, template_path, output_path)
    
    assert result is True
    assert os.path.exists(output_path)
    
    # Validate OPF file structure with custom template elements
    with open(output_path, "r", encoding="utf-8") as f:
        content = f.read()
        assert "<?xml" in content
        assert "<package" in content
        assert "<dc:title" in content
        assert "<dc:language" in content
        assert "<reference type=\"text\"" in content
        # Check for custom template elements
        assert "Custom Template" in content
```

#### 3.6.3 SQLite Export Tests

- **Basic Export**: Test basic SQLite export
- **Schema Validation**: Test validation of exported schema
- **Data Integrity**: Test data integrity in exported database
- **Performance**: Test export performance with large dictionaries
- **Compression**: Test compression of exported database

#### 3.6.4 Sample Test Cases for SQLite Export

```python
def test_basic_sqlite_export(sqlite_exporter, sample_entries):
    """Test basic SQLite export functionality."""
    output_path = "tests/fixtures/output/sqlite_export_test.db"
    result = sqlite_exporter.export(sample_entries, output_path)
    
    assert result is True
    assert os.path.exists(output_path)
    
    # Validate SQLite database
    conn = sqlite3.connect(output_path)
    cursor = conn.cursor()
    
    # Check tables exist
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    tables = cursor.fetchall()
    assert ("main_entries",) in tables
    assert ("variant_headwords",) in tables
    assert ("entry_relationships",) in tables
    
    # Check data was exported
    cursor.execute("SELECT COUNT(*) FROM main_entries;")
    count = cursor.fetchone()[0]
    assert count > 0
    
    conn.close()

def test_sqlite_export_with_variants(sqlite_exporter, sample_entries_with_variants):
    """Test SQLite export with variant forms."""
    output_path = "tests/fixtures/output/sqlite_variants_export_test.db"
    result = sqlite_exporter.export(sample_entries_with_variants, output_path)
    
    assert result is True
    assert os.path.exists(output_path)
    
    # Validate SQLite database with variants
    conn = sqlite3.connect(output_path)
    cursor = conn.cursor()
    
    # Check variant data was exported
    cursor.execute("SELECT COUNT(*) FROM variant_headwords;")
    variant_count = cursor.fetchone()[0]
    assert variant_count > 0
    
    # Check relationships were exported
    cursor.execute("SELECT COUNT(*) FROM entry_relationships;")
    relationship_count = cursor.fetchone()[0]
    assert relationship_count > 0
    
    conn.close()
```

### 3.7 Import Tests

#### 3.7.1 LIFT Import Tests

- **Basic Import**: Test basic LIFT import
- **Large Files**: Test import of large LIFT files
- **Validation**: Test validation during import
- **Error Handling**: Test error handling during import
- **Performance**: Test import performance

#### 3.7.2 Sample Test Cases for LIFT Import

```python
def test_basic_lift_import(lift_importer):
    """Test basic LIFT import functionality."""
    input_path = "tests/fixtures/lift_files/small_dictionary.lift"
    result = lift_importer.import_file(input_path)
    
    assert result.success is True
    assert result.entries_processed > 0
    assert result.entries_imported > 0
    assert result.errors == 0

def test_lift_import_with_validation(lift_importer):
    """Test LIFT import with validation."""
    input_path = "tests/fixtures/lift_files/dictionary_with_errors.lift"
    result = lift_importer.import_file(input_path, validate=True)
    
    assert result.success is False
    assert result.entries_processed > 0
    assert result.entries_imported < result.entries_processed
    assert result.errors > 0
    assert len(result.error_details) > 0

def test_lift_import_with_conflict_resolution(lift_importer):
    """Test LIFT import with conflict resolution."""
    input_path = "tests/fixtures/lift_files/dictionary_with_conflicts.lift"
    result = lift_importer.import_file(
        input_path,
        conflict_resolution="overwrite"
    )
    
    assert result.success is True
    assert result.entries_processed > 0
    assert result.entries_imported > 0
    assert result.conflicts > 0
    assert result.conflicts_resolved == result.conflicts
```

### 3.8 Pronunciation Tests

#### 3.8.1 IPA Validation Tests

- **Character Validation**: Test validation of IPA characters
- **Sequence Validation**: Test validation of IPA sequences
- **Error Reporting**: Test detailed error reporting
- **Suggestion System**: Test suggestion system for corrections
- **Dialect Variations**: Test handling of dialect variations

#### 3.8.2 Sample Test Cases for IPA Validation

```python
def test_ipa_character_validation(ipa_validator):
    """Test validation of IPA characters."""
    # Valid IPA characters
    assert ipa_validator.validate_characters("əˈseptəns") is True
    
    # Invalid IPA characters
    assert ipa_validator.validate_characters("test123") is False
    errors = ipa_validator.get_validation_errors("test123")
    assert len(errors) > 0
    assert any("Invalid character" in error for error in errors)

def test_ipa_sequence_validation(ipa_validator):
    """Test validation of IPA sequences."""
    # Valid sequence
    assert ipa_validator.validate_sequence("əˈseptəns") is True
    
    # Invalid sequence (double stress marker)
    assert ipa_validator.validate_sequence("əˈˈseptəns") is False
    errors = ipa_validator.get_validation_errors("əˈˈseptəns")
    assert len(errors) > 0
    assert any("Invalid sequence" in error for error in errors)

def test_ipa_suggestion_system(ipa_validator):
    """Test suggestion system for IPA corrections."""
    suggestions = ipa_validator.get_suggestions("əˈˈseptəns")
    assert len(suggestions) > 0
    assert "əˈseptəns" in suggestions
```

#### 3.8.3 TTS Integration Tests

- **Audio Generation**: Test generation of audio from text
- **Audio Storage**: Test storage and retrieval of audio
- **Error Handling**: Test handling of TTS service errors
- **Batch Processing**: Test batch processing of TTS requests
- **Dialect Support**: Test support for different dialects

#### 3.8.4 Sample Test Cases for TTS Integration

```python
def test_tts_audio_generation(tts_service, mock_google_tts):
    """Test generation of audio from text."""
    audio_data = tts_service.generate_audio("test", "en-US")
    assert audio_data is not None
    assert len(audio_data) > 0

def test_tts_audio_storage(tts_service, mock_google_tts):
    """Test storage and retrieval of audio."""
    # Generate and store audio
    entry_id = "test_entry"
    audio_path = tts_service.generate_and_store_audio(entry_id, "test", "en-US")
    assert audio_path is not None
    assert os.path.exists(audio_path)
    
    # Retrieve audio
    retrieved_path = tts_service.get_audio_path(entry_id)
    assert retrieved_path is not None
    assert retrieved_path == audio_path

def test_tts_service_error_handling(tts_service, mock_google_tts_error):
    """Test handling of TTS service errors."""
    with pytest.raises(TTSServiceError):
        tts_service.generate_audio("test", "en-US")
```

## 4. Mock Objects and Fixtures

### 4.1 BaseX Mock

```python
@pytest.fixture
def mock_basex_server():
    """Mock BaseX server for testing."""
    with mock.patch("app.database.basex_connector.BaseXServer") as mock_server:
        mock_server.return_value.connect.return_value = True
        mock_server.return_value.is_connected.return_value = True
        mock_server.return_value.disconnect.return_value = True
        mock_server.return_value.execute_query.return_value = MockQueryResult("0")
        yield mock_server

@pytest.fixture
def mock_basex_server_delayed():
    """Mock BaseX server with connection delay for testing timeouts."""
    with mock.patch("app.database.basex_connector.BaseXServer") as mock_server:
        def delayed_connect(*args, **kwargs):
            import time
            time.sleep(2)  # 2 second delay
            return True
        
        mock_server.return_value.connect.side_effect = delayed_connect
        yield mock_server
```

### 4.2 Google TTS Mock

```python
@pytest.fixture
def mock_google_tts():
    """Mock Google TTS client for testing."""
    with mock.patch("google.cloud.texttospeech.TextToSpeechClient") as mock_client:
        mock_response = mock.Mock()
        mock_response.audio_content = b"mock_audio_data"
        mock_client.return_value.synthesize_speech.return_value = mock_response
        yield mock_client

@pytest.fixture
def mock_google_tts_error():
    """Mock Google TTS client that raises an error."""
    with mock.patch("google.cloud.texttospeech.TextToSpeechClient") as mock_client:
        mock_client.return_value.synthesize_speech.side_effect = Exception("TTS service error")
        yield mock_client
```

### 4.3 Sample Data Fixtures

```python
@pytest.fixture
def sample_entries():
    """Sample dictionary entries for testing."""
    entries = []
    
    entry1 = Entry(id="test_entry1")
    entry1.lexical_unit = {"en": "test1"}
    entry1.pronunciations = {"seh-fonipa": "test1"}
    sense1 = Sense(id="sense1")
    sense1.definitions = {"pl": "próba1"}
    sense1.grammatical_info = "Noun"
    entry1.add_sense(sense1)
    
    entry2 = Entry(id="test_entry2")
    entry2.lexical_unit = {"en": "test2"}
    entry2.pronunciations = {"seh-fonipa": "test2"}
    sense2 = Sense(id="sense2")
    sense2.definitions = {"pl": "próba2"}
    sense2.grammatical_info = "Verb"
    entry2.add_sense(sense2)
    
    entries.append(entry1)
    entries.append(entry2)
    
    return entries

@pytest.fixture
def sample_entries_with_variants():
    """Sample dictionary entries with variant forms for testing."""
    entries = []
    
    entry1 = Entry(id="test_entry1")
    entry1.lexical_unit = {"en": "test1"}
    entry1.variant_forms = [
        {"form": {"en": "test1 variant1"}},
        {"form": {"en": "test1 variant2"}}
    ]
    sense1 = Sense(id="sense1")
    sense1.definitions = {"pl": "próba"}
    entry1.add_sense(sense1)
    
    entry2 = Entry(id="test_entry2")
    entry2.lexical_unit = {"en": "test2"}
    entry2.variant_forms = [
        {"form": {"en": "test2 variant1"}}
    ]
    sense2 = Sense(id="sense2")
    sense2.definitions = {"pl": "próba2"}
    entry2.add_sense(sense2)
    
    entries.append(entry1)
    entries.append(entry2)
    
    return entries
```

## 5. Test Coverage Goals

### 5.1 Coverage Metrics

- **Line Coverage**: Aim for 90%+ line coverage
- **Branch Coverage**: Aim for 85%+ branch coverage
- **Function/Method Coverage**: Aim for 95%+ function coverage
- **Class Coverage**: Aim for 100% class coverage

### 5.2 Critical Areas for Coverage

- **Data Model**: 100% coverage of core data models
- **BaseX Connector**: 100% coverage of database operations
- **LIFT Parser/Generator**: 100% coverage of parsing and generation logic
- **API Endpoints**: 100% coverage of all API endpoints
- **Export/Import**: 100% coverage of all export/import functionality
- **Validation**: 100% coverage of all validation rules

## 6. CI/CD Integration

### 6.1 GitHub Actions Workflow

```yaml
name: Python Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      basex:
        image: basex/basexhttp:latest
        ports:
          - 1984:1984
          - 8984:8984
        env:
          BASEX_USER: admin
          BASEX_PASSWORD: admin
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: 3.9
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        pip install pytest pytest-cov
    
    - name: Test with pytest
      run: |
        pytest --cov=app tests/
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
```

### 6.2 Pre-commit Configuration

```yaml
repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
    -   id: trailing-whitespace
    -   id: end-of-file-fixer
    -   id: check-yaml
    -   id: check-added-large-files

-   repo: https://github.com/psf/black
    rev: 23.3.0
    hooks:
    -   id: black

-   repo: https://github.com/pycqa/flake8
    rev: 6.0.0
    hooks:
    -   id: flake8
        additional_dependencies: [flake8-docstrings]

-   repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
    -   id: isort

-   repo: local
    hooks:
    -   id: pytest-check
        name: pytest-check
        entry: pytest
        language: system
        pass_filenames: false
        always_run: true
```

## 7. Test Documentation

### 7.1 Test Documentation Guidelines

- Each test file should include a module docstring explaining its purpose
- Each test class should include a class docstring explaining what it tests
- Each test method should include a docstring explaining what it tests
- Test fixtures should include docstrings explaining their purpose
- Complex test logic should include inline comments

### 7.2 Sample Test Documentation

```python
"""
Tests for the LIFT parser module.

This module contains tests for the LIFT parser, which is responsible for
parsing LIFT format XML files into dictionary entry objects.
"""

import pytest
from app.parsers.lift_parser import LIFTParser

class TestLIFTParser:
    """Test suite for the LIFT parser module."""
    
    def test_parse_valid_lift_file(self):
        """
        Test parsing a valid LIFT file with standard elements.
        
        This test verifies that the parser can correctly parse a valid LIFT file
        and extract the expected entries with their attributes.
        """
        parser = LIFTParser()
        entries = parser.parse("tests/fixtures/valid_lift_file.lift")
        
        assert entries is not None
        assert len(entries) > 0
        # Verify the first entry has expected structure
        assert "id" in entries[0]
        assert "lexical_unit" in entries[0]
```

## 8. Example and Sense Management Tests

### 8.1 Example Allocation Testing

#### 8.1.1 LLM-Assisted Example Allocation

- **Algorithm Validation**: Test example allocation algorithms with known datasets
- **Confidence Scoring**: Test confidence score calculation and thresholds
- **Ambiguity Detection**: Test detection of ambiguous examples
- **Batch Processing**: Test batch allocation of examples to senses
- **Performance**: Test performance with large example sets

#### 8.1.2 Sample Test Cases for Example Allocation

```python
def test_example_allocation_algorithm(example_allocator, sample_entries_with_examples):
    """Test basic example allocation functionality."""
    # Get unallocated examples
    unallocated_examples = []
    for entry in sample_entries_with_examples:
        for example in entry.unallocated_examples:
            unallocated_examples.append({
                "entry_id": entry.id,
                "example_text": example.form["en"],
                "example_id": example.id
            })
    
    # Run allocation
    results = example_allocator.allocate_examples(unallocated_examples)
    
    assert len(results) == len(unallocated_examples)
    assert all("sense_id" in result for result in results)
    assert all("confidence" in result for result in results)

def test_example_allocation_confidence_thresholds(example_allocator, ambiguous_examples):
    """Test confidence thresholds for example allocation."""
    # Run allocation with different confidence thresholds
    results_low = example_allocator.allocate_examples(ambiguous_examples, min_confidence=0.3)
    results_high = example_allocator.allocate_examples(ambiguous_examples, min_confidence=0.8)
    
    # Higher threshold should result in fewer allocations
    assert len([r for r in results_low if r["sense_id"] is not None]) > \
           len([r for r in results_high if r["sense_id"] is not None])
    
    # Check that low-confidence results are marked for review
    review_candidates = [r for r in results_low if r["confidence"] < 0.8]
    assert all(r["needs_review"] for r in review_candidates)

def test_batch_example_allocation(example_allocator, large_example_set):
    """Test batch allocation of examples to senses."""
    # Run batch allocation
    results = example_allocator.batch_allocate(large_example_set)
    
    assert len(results) == len(large_example_set)
    assert all("processing_time" in result for result in results)
    
    # Check allocation statistics
    allocation_stats = example_allocator.get_allocation_statistics(results)
    assert "allocated_count" in allocation_stats
    assert "unallocated_count" in allocation_stats
    assert "average_confidence" in allocation_stats
```

### 8.2 Sense Mapping Tests

#### 8.2.1 WordNet Integration

- **Synset Mapping**: Test mapping dictionary senses to WordNet synsets
- **Coverage Analysis**: Test analysis of sense coverage compared to WordNet
- **Missing Sense Detection**: Test detection of missing senses
- **Hierarchy Organization**: Test sense hierarchy organization based on WordNet

#### 8.2.2 Sample Test Cases for WordNet Integration

```python
def test_wordnet_synset_mapping(wordnet_mapper, sample_entries):
    """Test mapping dictionary senses to WordNet synsets."""
    # Map senses to WordNet
    mapping_results = wordnet_mapper.map_entries_to_wordnet(sample_entries)
    
    assert len(mapping_results) == len(sample_entries)
    assert all("wordnet_mappings" in result for result in mapping_results)
    
    # Check that at least some mappings were found
    mappings_found = sum(len(result["wordnet_mappings"]) for result in mapping_results)
    assert mappings_found > 0

def test_sense_coverage_analysis(wordnet_mapper, sample_entries):
    """Test analysis of sense coverage compared to WordNet."""
    # Analyze coverage
    coverage_results = wordnet_mapper.analyze_coverage(sample_entries)
    
    assert "total_senses" in coverage_results
    assert "mapped_senses" in coverage_results
    assert "coverage_percentage" in coverage_results
    assert "missing_synsets" in coverage_results
    
    # Check that coverage percentage is calculated correctly
    expected_percentage = (coverage_results["mapped_senses"] / coverage_results["total_senses"]) * 100
    assert abs(coverage_results["coverage_percentage"] - expected_percentage) < 0.01

def test_missing_sense_detection(wordnet_mapper, incomplete_entries):
    """Test detection of missing senses."""
    # Detect missing senses
    missing_sense_results = wordnet_mapper.detect_missing_senses(incomplete_entries)
    
    assert len(missing_sense_results) == len(incomplete_entries)
    assert all("missing_senses" in result for result in missing_sense_results)
    
    # At least some entries should have missing senses
    entries_with_missing = sum(1 for result in missing_sense_results if result["missing_senses"])
    assert entries_with_missing > 0
    
    # Check that suggested definitions are provided
    for result in missing_sense_results:
        if result["missing_senses"]:
            assert all("suggested_definition" in sense for sense in result["missing_senses"])
```
