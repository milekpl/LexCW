"""
Comprehensive unit tests for the Entry model to achieve high coverage.

Following TDD approach as specified in project requirements.
"""
from __future__ import annotations

import pytest
from typing import Dict, List, Any

from app.models.entry import Entry
from app.models.sense import Sense
from app.models.example import Example
from app.models.pronunciation import Pronunciation
from app.utils.exceptions import ValidationError


class TestEntryModelComprehensive:
    """Comprehensive tests for Entry model covering all functionality."""
    
    def test_entry_initialization_minimal(self):
        """Test entry creation with minimal required data."""
        entry = Entry(
            id_="test_minimal",
            lexical_unit={"en": "test"}
        )
        
        assert entry.id == "test_minimal"
        assert entry.lexical_unit == {"en": "test"}
        assert entry.senses == []
        assert entry.pronunciations == {}  # It's a dict, not a list
        assert entry.citations == []
        assert entry.variants == []
        assert entry.relations == []
        assert entry.notes == {}  # It's a dict, not a list
        assert entry.custom_fields == {}
    
    def test_entry_initialization_full(self):
        """Test entry creation with all possible data."""
        sense = Sense(
            id="test_sense",
            gloss="Test gloss",
            definition="Test definition"
        )
        
        entry = Entry(
            id_="test_full",
            lexical_unit={"en": "test", "pl": "testowy"},
            senses=[sense],
            pronunciations={"en": "test_pronunciation"},
            citations=[{"form": "test", "lang": "en"}],
            relations=[{"type": "synonym", "ref": "other_entry"}],
            notes={"general": "Test note"},
            grammatical_info="Noun",
            variant_forms=[{"form": "teste", "lang": "en"}],
            custom_fields={"field1": "value1"}
        )
        
        assert entry.id == "test_full"
        assert len(entry.senses) == 1
        assert entry.pronunciations == {"en": "test_pronunciation"}
        assert len(entry.citations) == 1
        assert len(entry.relations) == 1
        assert entry.notes == {"general": "Test note"}
        assert entry.grammatical_info == "Noun"
        assert len(entry.variant_forms) == 1
        assert entry.custom_fields == {"field1": "value1"}
    
    def test_entry_from_dict_minimal(self):
        """Test creating entry from dictionary with minimal data."""
        data = {
            "id": "from_dict_minimal",
            "lexical_unit": {"en": "test"}
        }
        
        entry = Entry.from_dict(data)
        assert entry.id == "from_dict_minimal"
        assert entry.lexical_unit == {"en": "test"}
        assert entry.senses == []
    
    def test_entry_from_dict_full(self):
        """Test creating entry from dictionary with full data."""
        data = {
            "id": "from_dict_full",
            "lexical_unit": {"en": "test", "pl": "testowy"},
            "senses": [
                {
                    "id": "sense_1",
                    "gloss": "Test gloss",
                    "definition": "Test definition"
                }
            ],
            "pronunciations": {"en": "test_pronunciation"},
            "citations": [{"form": "test"}],
            "relations": [{"type": "synonym", "ref": "other_entry"}],
            "notes": {"general": "Test note"},
            "grammatical_info": "Noun",
            "variant_forms": [{"form": "teste"}],
            "custom_fields": {"field1": "value1"}
        }
        
        entry = Entry.from_dict(data)
        assert entry.id == "from_dict_full"
        assert len(entry.senses) == 1
        assert entry.pronunciations == {"en": "test_pronunciation"}
        assert len(entry.citations) == 1
        assert len(entry.relations) == 1
        assert entry.notes == {"general": "Test note"}
        assert entry.grammatical_info == "Noun"
        assert len(entry.variant_forms) == 1
        assert entry.custom_fields == {"field1": "value1"}
    
    def test_entry_to_dict_minimal(self):
        """Test converting minimal entry to dictionary."""
        entry = Entry(
            id="to_dict_minimal",
            lexical_unit={"en": "test"}
        )
        
        data = entry.to_dict()
        assert data["id"] == "to_dict_minimal"
        assert data["lexical_unit"] == {"en": "test"}
        assert data["senses"] == []
        assert "headword" not in data  # Should not include headword property
    
    def test_entry_to_dict_full(self):
        """Test converting full entry to dictionary."""
        sense = Sense(
            id="sense_1",
            gloss="Test gloss",
            definition="Test definition"
        )
        
        entry = Entry(
            id="to_dict_full",
            lexical_unit={"en": "test"},
            senses=[sense],
            notes=["Test note"]
        )
        
        data = entry.to_dict()
        assert data["id"] == "to_dict_full"
        assert len(data["senses"]) == 1
        assert data["senses"][0]["id"] == "sense_1"
        assert data["notes"] == ["Test note"]
    
    def test_entry_validation_valid(self):
        """Test validation of valid entry."""
        entry = Entry(
            id_="valid_entry",
            lexical_unit={"en": "test"}
        )
        
        # Should not raise exception
        assert entry.validate() is True
    
    def test_entry_validation_missing_id(self):
        """Test validation fails for missing ID."""
        entry = Entry(
            id_="",
            lexical_unit={"en": "test"}
        )
        
        with pytest.raises(ValidationError) as exc_info:
            entry.validate()
        
        assert "Entry ID is required" in str(exc_info.value)
    
    def test_entry_validation_missing_lexical_unit(self):
        """Test validation fails for missing lexical unit."""
        entry = Entry(
            id_="test_entry",
            lexical_unit={}
        )
        
        with pytest.raises(ValidationError) as exc_info:
            entry.validate()
        
        assert "Lexical unit is required" in str(exc_info.value)
    
    def test_entry_validation_sense_without_id(self):
        """Test that senses without ID get auto-generated IDs."""
        entry = Entry(
            id_="test_entry",
            lexical_unit={"en": "test"},
            senses=[{"gloss": "test"}]  # Missing ID will be auto-generated
        )
        
        # Validation should pass because Sense auto-generates IDs
        assert entry.validate() is True
        
        # Check that the sense got an auto-generated ID
        assert len(entry.senses) == 1
        assert entry.senses[0].id is not None
        assert entry.senses[0].id != ""
    
    def test_entry_str_representation(self):
        """Test string representation of entry."""
        entry = Entry(
            id_="test_str",
            lexical_unit={"en": "test"}
        )
        
        str_repr = str(entry)
        assert "test_str" in str_repr
    
    def test_entry_repr_representation(self):
        """Test repr representation of entry."""
        entry = Entry(
            id_="test_repr",
            lexical_unit={"en": "test"}
        )
        
        repr_str = repr(entry)
        assert "Entry" in repr_str
        assert "test_repr" in repr_str
    
    def test_entry_from_dict_with_senses_dict(self):
        """Test creating entry from dict where senses are already dict objects."""
        data = {
            "id": "test_senses_dict",
            "lexical_unit": {"en": "test"},
            "senses": [
                {
                    "id": "sense_1",
                    "gloss": "Test gloss"
                }
            ]
        }
        
        entry = Entry.from_dict(data)
        assert len(entry.senses) == 1
        assert entry.senses[0].id == "sense_1"
    
    def test_entry_with_complex_relations(self):
        """Test entry with complex relation structures."""
        entry = Entry(
            id_="relations_test",
            lexical_unit={"en": "test"},
            relations=[
                {"type": "synonym", "ref": "entry1"},
                {"type": "antonym", "ref": "entry2"},
                {"type": "variant", "ref": "entry3", "note": "archaic"}
            ]
        )
        
        assert len(entry.relations) == 3
        synonym_rel = next(r for r in entry.relations if r.type == "synonym")
        assert synonym_rel.ref == "entry1"
        
        variant_rel = next(r for r in entry.relations if r.type == "variant")
        assert hasattr(variant_rel, 'note') and getattr(variant_rel, 'note', None) == "archaic"
    
    def test_entry_with_custom_fields(self):
        """Test entry with custom fields."""
        entry = Entry(
            id_="custom_fields_test",
            lexical_unit={"en": "test"},
            custom_fields={
                "field1": "value1",
                "field2": {"subfield": "value2"},
                "field3": ["item1", "item2"]
            }
        )
        
        assert entry.custom_fields["field1"] == "value1"
        assert entry.custom_fields["field2"]["subfield"] == "value2"
        assert len(entry.custom_fields["field3"]) == 2
    
    def test_entry_add_sense_method(self):
        """Test the add_sense method if it exists."""
        entry = Entry(
            id_="add_sense_test",
            lexical_unit={"en": "test"}
        )
        
        # Test adding a sense as a dictionary
        sense_data = {
            "id": "new_sense",
            "gloss": "New gloss",
            "definition": "New definition"
        }
        
        # Check if add_sense method exists
        if hasattr(entry, 'add_sense'):
            entry.add_sense(sense_data)
            assert len(entry.senses) == 1
        else:
            # Manually add to senses list
            from app.models.sense import Sense
            entry.senses.append(Sense(**sense_data))
            assert len(entry.senses) == 1
