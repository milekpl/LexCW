{
  "version": "2.0",
  "description": "Fully declarative validation rules - no hardcoded Python logic required",
  "rules": {
    "R1.1.1": {
      "name": "entry_id_required",
      "description": "Entry ID is required and must be non-empty",
      "category": "entry_level",
      "priority": "critical",
      "path": "$.id",
      "condition": {
        "type": "required"
      },
      "validation": {
        "type": "string",
        "minLength": 1
      },
      "error_message": "Entry ID is required and must be non-empty"
    },
    "R1.1.2": {
      "name": "lexical_unit_required",
      "description": "Lexical unit is required and must contain at least one language entry",
      "category": "entry_level",
      "priority": "critical",
      "path": "$.lexical_unit",
      "condition": {
        "type": "required"
      },
      "validation": {
        "type": "object",
        "minProperties": 1
      },
      "error_message": "Lexical unit is required and must contain at least one language entry"
    },
    "R1.1.3": {
      "name": "sense_required_non_variant",
      "description": "At least one sense is required per entry (except for variant entries)",
      "category": "entry_level",
      "priority": "critical",
      "path": "$.senses",
      "condition": {
        "type": "conditional",
        "when": {
          "not": {
            "path": "$.relations[*]",
            "contains": {
              "field": "type",
              "value": "_component-lexeme"
            }
          }
        }
      },
      "validation": {
        "type": "array",
        "minItems": 1
      },
      "error_message": "At least one sense is required per entry",
      "validation_mode": "save_only"
    },
    "R1.2.1": {
      "name": "entry_id_format",
      "description": "Entry ID must match valid format pattern",
      "category": "entry_level",
      "priority": "critical",
      "path": "$.id",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9_\\- ]+$"
      },
      "error_message": "Invalid entry ID format. Use only letters, numbers, underscores, hyphens, and spaces"
    },
    "R1.2.2": {
      "name": "lexical_unit_content_validation",
      "description": "Lexical unit content must be non-empty strings",
      "category": "entry_level",
      "priority": "critical",
      "path": "$.lexical_unit.*",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "string",
        "minLength": 1,
        "pattern": "\\S+"
      },
      "error_message": "Lexical unit content cannot be empty or contain only whitespace"
    },
    "R1.2.3": {
      "name": "language_code_validation",
      "description": "Lexical unit must contain at least one language",
      "category": "entry_level",
      "priority": "critical",
      "path": "$.lexical_unit",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "object",
        "minProperties": 1
      },
      "error_message": "Lexical unit must contain at least one language"
    },
    "R2.1.1": {
      "name": "sense_id_required",
      "description": "Sense ID is required and must be non-empty",
      "category": "sense_level",
      "priority": "critical",
      "path": "$.senses[*].id",
      "condition": {
        "type": "required"
      },
      "validation": {
        "type": "string",
        "minLength": 1
      },
      "error_message": "Sense ID is required and must be non-empty"
    },
    "R2.1.2": {
      "name": "sense_content_or_variant",
      "description": "Sense must have definition, gloss, or variant reference",
      "category": "sense_level",
      "priority": "critical",
      "path": "$.senses[*]",
      "condition": {
        "type": "required"
      },
      "validation": {
        "type": "logic",
        "operator": "or",
        "conditions": [
          {
            "path": "definition",
            "type": "object_has_non_empty_value"
          },
          {
            "path": "gloss",
            "type": "object_has_non_empty_value"
          },
          {
            "path": "variant_of",
            "type": "non_empty_string"
          },
          {
            "path": "is_variant",
            "type": "equals",
            "value": true
          }
        ]
      },
      "error_message": "Sense must have definition, gloss, or be a variant reference"
    },
    "R2.2.1": {
      "name": "definition_content_validation",
      "description": "Sense definitions must have at least one non-empty language value",
      "category": "sense_level",
      "priority": "critical",
      "path": "$.senses[*].definition",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "object_has_non_empty_value"
      },
      "error_message": "Sense definition cannot be empty or contain only whitespace"
    },
    "R2.2.2": {
      "name": "gloss_content_validation",
      "description": "Sense glosses must have at least one non-empty language value",
      "category": "sense_level",
      "priority": "critical",
      "path": "$.senses[*].gloss",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "object_has_non_empty_value"
      },
      "error_message": "Sense gloss cannot be empty or contain only whitespace"
    },
    "R2.2.3": {
      "name": "example_text_validation",
      "description": "Example texts must be non-empty when example is present",
      "category": "sense_level",
      "priority": "critical",
      "path": "$.senses[*].examples[*].text",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "string",
        "minLength": 1,
        "pattern": "\\S+"
      },
      "error_message": "Example text cannot be empty or contain only whitespace"
    },
    "R3.1.1": {
      "name": "unique_note_types",
      "description": "Note types must be unique within entry",
      "category": "notes_level",
      "priority": "warning",
      "path": "$.notes",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "object_unique_keys"
      },
      "error_message": "Duplicate note type found"
    },
    "R3.2.1": {
      "name": "multilingual_note_structure",
      "description": "Multilingual notes must be objects with at least one language",
      "category": "notes_level",
      "priority": "critical",
      "path": "$.notes.*",
      "condition": {
        "type": "if_type",
        "value_type": "object"
      },
      "validation": {
        "type": "object",
        "minProperties": 1
      },
      "error_message": "Multilingual note must contain at least one language"
    },
    "R4.1.1": {
      "name": "pronunciation_language_codes",
      "description": "Pronunciation language codes must be valid",
      "category": "pronunciation_level",
      "priority": "critical",
      "path": "$.pronunciations",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "object",
        "keys_in": ["pl-fonipa", "en-fonipa", "seh-fonipa", "ipa"]
      },
      "error_message": "Invalid pronunciation language code"
    },
    "R5.1.1": {
      "name": "synonym_antonym_exclusion",
      "description": "Entries cannot be both synonym and antonym",
      "category": "relations_level",
      "priority": "warning",
      "path": "$.relations",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "logic",
        "operator": "not",
        "conditions": [
          {
            "type": "logic",
            "operator": "and",
            "conditions": [
              {
                "type": "array_contains",
                "field": "type",
                "value": "synonym"
              },
              {
                "type": "array_contains",
                "field": "type",
                "value": "antonym"
              }
            ]
          }
        ]
      },
      "error_message": "Entry cannot have both synonym and antonym relations to the same entry"
    },
    "R5.2.1": {
      "name": "subsense_depth",
      "description": "Subsense nesting must not exceed 3 levels",
      "category": "sense_level",
      "priority": "warning",
      "path": "$.senses[*]",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "max_nesting_depth",
        "field": "subsenses",
        "max_depth": 3
      },
      "error_message": "Subsense nesting exceeds maximum depth of 3"
    },
    "R6.1.1": {
      "name": "unique_languages_in_multitext",
      "description": "Language codes must be unique in multilingual content",
      "category": "general",
      "priority": "critical",
      "path": "$.senses[*].definition",
      "condition": {
        "type": "if_type",
        "value_type": "object"
      },
      "validation": {
        "type": "object_unique_keys"
      },
      "error_message": "Duplicate language code found in multilingual content"
    },
    "R7.1.1": {
      "name": "date_fields_format",
      "description": "Date fields must be in ISO8601 format",
      "category": "entry_level",
      "priority": "warning",
      "path": "$.[date_created,date_modified]",
      "condition": {
        "type": "if_present"
      },
      "validation": {
        "type": "string",
        "pattern": "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}"
      },
      "error_message": "Date field must be in ISO8601 format (YYYY-MM-DDTHH:MM:SS)"
    },
    "R8.1.1": {
      "name": "no_circular_component_references",
      "description": "Component relations must not reference the entry itself",
      "category": "relation_validation",
      "priority": "critical",
      "path": "$.relations[*]",
      "condition": {
        "type": "custom"
      },
      "validation": {
        "type": "custom",
        "custom_function": "validate_no_circular_components"
      },
      "error_message": "Component relation cannot reference the entry itself (circular reference)"
    },
    "R8.1.2": {
      "name": "no_circular_sense_references",
      "description": "Sense relations must not reference senses within the same entry",
      "category": "relation_validation",
      "priority": "critical",
      "path": "$.senses[*].relations[*]",
      "condition": {
        "type": "custom"
      },
      "validation": {
        "type": "custom",
        "custom_function": "validate_no_circular_sense_relations"
      },
      "error_message": "Sense relation cannot reference a sense within the same entry (circular reference)"
    },
    "R8.1.3": {
      "name": "no_circular_entry_references",
      "description": "Entry-level relations must not reference the entry itself",
      "category": "relation_validation",
      "priority": "critical",
      "path": "$.relations[*]",
      "condition": {
        "type": "custom"
      },
      "validation": {
        "type": "custom",
        "custom_function": "validate_no_circular_entry_relations"
      },
      "error_message": "Entry relation cannot reference the entry itself (circular reference)"
    }
  }
}
